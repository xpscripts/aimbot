-- xp;scripts - integrated with AppleLibrary UI
-- Ultimate Enhanced ESP + Aimbot (mobile-friendly) — English
-- Notes:
--  * This version fixes a few bugs (scope issues, accidental 'continue', math.clamp usage,
--    local variable scoping for box sizes) and removes the in-script CoreGui UI so the
--    controls are exposed via the external AppleLibrary UI provided at:
--    https://github.com/GoHamza/AppleLibrary (loaded at runtime).
--  * All state toggles / numeric inputs are bound to the UI, and settings are saved.
--  * If the AppleLibrary can't be fetched or an API isn't available (Drawing/Highlight/writefile),
--    the script gracefully falls back to available features.
--  * To change default hotkeys or controls, edit the CONFIG table below.

-- ====== Services & Locals ======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- ====== Compatibility & Utilities ======
local hasDrawing, Drawing = pcall(function() return Drawing end) and Drawing or nil
local hasHighlight = pcall(function() return Instance.new("Highlight") end)
local canProtectGUI = (type(syn) == "table" and type(syn.protect_gui) == "function")
local canWriteFile = (type(writefile) == "function" and type(readfile) == "function" and type(isfile) == "function")
local fileName = "xp_scripts_settings.json"

local function safeWriteFile(name, data)
    if canWriteFile then
        pcall(function() writefile(name, data) end)
        return true
    end
    return false
end
local function safeReadFile(name)
    if canWriteFile then
        local ok, content = pcall(function() return readfile(name) end)
        if ok then return content end
    end
    return nil
end
local function safeIsFile(name)
    if canWriteFile then
        local ok, val = pcall(function() return isfile(name) end)
        if ok then return val end
    end
    return false
end

local function clamp(v, a, b) if v < a then return a elseif v > b then return b else return v end end

-- ====== CONFIGURATION & STATE ======
local CONFIG = {
    name = "xp;scripts",
    aimMouseButton = Enum.UserInputType.MouseButton2, -- right-click default
    hotkeys = {
        toggleUI = Enum.KeyCode.RightControl,
        toggleESP = Enum.KeyCode.F1,
        toggleAimbot = Enum.KeyCode.F2,
        toggleGlow = Enum.KeyCode.F3,
    },
    mobileVirtualAimHoldTimeout = 0.05, -- seconds between aim updates while holding virtual button
    espUpdateInterval = 0.03, -- throttle
    maxESPRendered = 32, -- max players to process fully for performance
    uiToggleKey = Enum.KeyCode.RightShift, -- UI toggle for external library (for convenience)
}

local state = {
    uiVisible = true,
    espEnabled = false,
    glowEnabled = false,
    aimbotEnabled = false,
    teamCheck = false,
    wallCheck = false,
    targetPart = "Head",
    fovRadius = 150,
    showFov = false,
    fovRainbow = false,
    smoothingFactor = 0.5, -- 0 .. 1 (0 = instant snap)
    hue = 0,
    targetPriority = "Closest", -- "Closest", "LowestHealth", "ClosestVisible"
    tracersEnabled = false,
    healthBarsEnabled = true,
    colorPresets = {
        esp = {r=255,g=255,b=255},
        glow = {r=255,g=0,b=0},
        fov = {r=255,g=200,b=0}
    },
    rainbowESP = false,
    rainbowGlow = false,
    saveOnChange = true,
}

-- Try to load saved settings
if safeIsFile(fileName) then
    local raw = safeReadFile(fileName)
    if raw then
        local ok, parsed = pcall(function() return HttpService:JSONDecode(raw) end)
        if ok and type(parsed) == "table" then
            for k,v in pairs(parsed) do state[k] = v end
        end
    end
end

local function saveSettings()
    if not state.saveOnChange then return end
    local ok, encoded = pcall(function() return HttpService:JSONEncode(state) end)
    if ok then safeWriteFile(fileName, encoded) end
end

-- ====== Colors helpers ======
local function rgb(t) return Color3.fromRGB(t.r or 255, t.g or 255, t.b or 255) end
local function toRGBTable(c)
    return { r = math.floor(c.R*255 + 0.5), g = math.floor(c.G*255 + 0.5), b = math.floor(c.B*255 + 0.5) }
end

-- ====== Drawing objects & caches (no embedded in-script GUI) ==========
local espObjects = {}   -- player -> {box, name, distance, healthbar, tracer}
local glowObjects = {}  -- player -> list of highlights
local fovCircle = nil
if hasDrawing then
    local ok, circle = pcall(function() return Drawing.new("Circle") end)
    if ok and circle then
        fovCircle = circle
        fovCircle.Radius = state.fovRadius
        fovCircle.Visible = state.showFov
        fovCircle.Thickness = 2
        fovCircle.Transparency = 1
        fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        fovCircle.Color = rgb(state.colorPresets.fov)
    else
        fovCircle = nil
    end
end

-- Create per-player drawables
local function createESP(player)
    if player == LocalPlayer then return end
    if espObjects[player] then return end
    local t = {}
    if hasDrawing then
        pcall(function()
            t.box = Drawing.new("Square"); t.box.Visible = false; t.box.Filled = false; t.box.Thickness = 1
            t.name = Drawing.new("Text"); t.name.Visible = false; t.name.Center = true; t.name.Outline = true; t.name.Size = 14
            t.dist = Drawing.new("Text"); t.dist.Visible = false; t.dist.Center = true; t.dist.Outline = true; t.dist.Size = 12
            t.tracer = Drawing.new("Line"); t.tracer.Visible = false; t.tracer.Thickness = 1
            t.health = Drawing.new("Square"); t.health.Visible = false; t.health.Filled = true; t.health.Thickness = 0
            t.healthBack = Drawing.new("Square"); t.healthBack.Visible = false; t.healthBack.Filled = true
        end)
    end
    espObjects[player] = t
end
local function removeESP(player)
    local o = espObjects[player]
    if o then
        pcall(function()
            if o.box then o.box:Remove() end
            if o.name then o.name:Remove() end
            if o.dist then o.dist:Remove() end
            if o.tracer then o.tracer:Remove() end
            if o.health then o.health:Remove() end
            if o.healthBack then o.healthBack:Remove() end
        end)
        espObjects[player] = nil
    end
    if glowObjects[player] then
        for _,h in pairs(glowObjects[player]) do pcall(function() if h and h.Parent then h:Destroy() end end) end
        glowObjects[player] = nil
    end
end

for _,p in ipairs(Players:GetPlayers()) do createESP(p) end
Players.PlayerAdded:Connect(createESP)
Players.PlayerRemoving:Connect(removeESP)

-- ======= Visibility check (Raycast) =======
local function canSee(part)
    if not state.wallCheck then return true end
    if not part or not part.Parent then return false end
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    local ok, result = pcall(function()
        return Workspace:Raycast(origin, direction.Unit * math.min(direction.Magnitude, 2000), params)
    end)
    if not ok or not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(part.Parent) then
        return true
    end
    return false
end

-- ======= Glow (Highlight) management =======
local function updateGlowFor(player)
    if not state.glowEnabled or not state.espEnabled or not hasHighlight then
        if glowObjects[player] then
            for _,h in pairs(glowObjects[player]) do pcall(function() if h and h.Parent then h:Destroy() end end) end
            glowObjects[player] = nil
        end
        return
    end
    if player == LocalPlayer then return end
    if state.teamCheck and player.Team == LocalPlayer.Team then
        if glowObjects[player] then
            for _,h in pairs(glowObjects[player]) do pcall(function() if h and h.Parent then h:Destroy() end end) end
            glowObjects[player] = nil
        end
        return
    end
    local char = player.Character
    if not char then
        if glowObjects[player] then
            for _,h in pairs(glowObjects[player]) do pcall(function() if h and h.Parent then h:Destroy() end end) end
            glowObjects[player] = nil
        end
        return
    end
    if glowObjects[player] then
        for _,h in pairs(glowObjects[player]) do pcall(function() if h and h.Parent then h:Destroy() end end) end
    end
    glowObjects[player] = {}
    for _,part in pairs(char:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            local high = Instance.new("Highlight")
            high.Adornee = part
            local color = state.rainbowGlow and Color3.fromHSV(state.hue,1,1) or rgb(state.colorPresets.glow)
            high.FillColor = color
            high.OutlineColor = color
            high.FillTransparency = 0.7
            high.OutlineTransparency = 0
            high.Parent = game.CoreGui
            table.insert(glowObjects[player], high)
        end
    end
end

-- ======= Target selection & aimbot helpers =======
local function screenInfo(pos)
    local px, onScreen = Camera:WorldToViewportPoint(pos)
    return Vector3.new(px.X, px.Y, px.Z), onScreen == true
end

local function screenDistanceFromCenter(pos)
    local screenPos3, onScreen = Camera:WorldToViewportPoint(pos)
    local v2 = Vector2.new(screenPos3.X, screenPos3.Y)
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    return (v2 - center).Magnitude, onScreen == true, v2
end

local function collectCandidates()
    local list = {}
    for _,player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(state.targetPart) then
            if state.teamCheck and player.Team == LocalPlayer.Team then
                -- skip teammates when teamCheck is enabled
            else
                local part = player.Character[state.targetPart]
                if part then
                    local distCenter, onScreen, screenPos = screenDistanceFromCenter(part.Position)
                    table.insert(list, {player=player, part=part, distCenter=distCenter, onScreen=onScreen, screenPos=screenPos})
                end
            end
        end
    end
    return list
end

local function chooseTarget()
    local candidates = collectCandidates()
    -- filter by FOV & visibility depending on mode
    local filtered = {}
    for _,c in ipairs(candidates) do
        if c.onScreen and c.distCenter <= state.fovRadius then
            if state.targetPriority == "ClosestVisible" then
                if canSee(c.part) then table.insert(filtered, c) end
            else
                table.insert(filtered, c)
            end
        end
    end
    if #filtered == 0 then return nil end

    if state.targetPriority == "LowestHealth" then
        table.sort(filtered, function(a,b)
            local ah = a.player.Character and a.player.Character:FindFirstChildOfClass("Humanoid")
            local bh = b.player.Character and b.player.Character:FindFirstChildOfClass("Humanoid")
            local av = ah and ah.Health or 9999
            local bv = bh and bh.Health or 9999
            return av < bv
        end)
        return filtered[1].part
    else -- Closest or ClosestVisible both by distCenter
        table.sort(filtered, function(a,b) return a.distCenter < b.distCenter end)
        return filtered[1].part
    end
end

local function smoothLookAt(target)
    if not target then return end
    local start = Camera.CFrame
    local goal = CFrame.new(Camera.CFrame.Position, target.Position)
    local alpha = 1 - state.smoothingFactor -- 0..1, where 1 is instant
    alpha = clamp(alpha, 0, 1)
    if alpha >= 1 then
        Camera.CFrame = goal
    else
        Camera.CFrame = start:Lerp(goal, alpha)
    end
end

-- ======= ESP update/render loop =======
local lastESPUpdate = 0
local function updateESP(dt)
    lastESPUpdate = lastESPUpdate + dt
    if lastESPUpdate < CONFIG.espUpdateInterval then return end
    lastESPUpdate = 0

    -- update fov circle
    if fovCircle then
        fovCircle.Visible = state.showFov and state.aimbotEnabled
        fovCircle.Radius = state.fovRadius
        fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        if state.fovRainbow then
            state.hue = (state.hue + 0.007) % 1
            fovCircle.Color = Color3.fromHSV(state.hue, 1, 1)
        else
            fovCircle.Color = rgb(state.colorPresets.fov)
        end
    end

    -- collect all players, sort by distance to camera (fast early exit)
    local playersList = {}
    for _,player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude
                table.insert(playersList, {player=player, dist=dist})
            end
        end
    end
    table.sort(playersList, function(a,b) return a.dist < b.dist end)

    -- Only process up to maxESPRendered for performance (nearest players)
    local count = 0
    for _,entry in ipairs(playersList) do
        if count >= CONFIG.maxESPRendered then break end
        local player = entry.player
        count = count + 1

        -- ensure draws exist
        createESP(player)
        updateGlowFor(player) -- manage highlight objects

        local draws = espObjects[player]
        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not state.espEnabled then
            if draws then
                pcall(function()
                    if draws.box then draws.box.Visible = false end
                    if draws.name then draws.name.Visible = false end
                    if draws.dist then draws.dist.Visible = false end
                    if draws.tracer then draws.tracer.Visible = false end
                    if draws.health then draws.health.Visible = false; draws.healthBack.Visible = false end
                end)
            end
        else
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local target = char:FindFirstChild(state.targetPart) or hrp
            if target then
                local screenPos3, onScreen = Camera:WorldToViewportPoint(target.Position)
                local screenPos = Vector2.new(screenPos3.X, screenPos3.Y)
                local visible = canSee(target)
                if onScreen and (not state.teamCheck or player.Team ~= LocalPlayer.Team) then
                    if draws then
                        -- color handling
                        local espColor = state.rainbowESP and Color3.fromHSV(state.hue, 1, 1) or rgb(state.colorPresets.esp)
                        local tracerColor = espColor
                        local glowColor = state.rainbowGlow and Color3.fromHSV(state.hue, 1, 1) or rgb(state.colorPresets.glow)

                        -- compute box sizes in a scope visible to healthbar code
                        local sizeScale = clamp(1 / (screenPos3.Z * 0.002 + 0.001), 0.5, 3)
                        local boxW = 40 * sizeScale
                        local boxH = 80 * sizeScale

                        if draws.box then
                            draws.box.Size = Vector2.new(boxW, boxH)
                            draws.box.Position = Vector2.new(screenPos.X - boxW/2, screenPos.Y - boxH/2 - 20)
                            draws.box.Color = espColor
                            draws.box.Visible = true
                        end
                        if draws.name then
                            draws.name.Position = Vector2.new(screenPos.X, screenPos.Y - 60)
                            draws.name.Text = player.Name
                            draws.name.Color = espColor
                            draws.name.Visible = true
                        end
                        if draws.dist then
                            local distance = math.floor((Camera.CFrame.Position - target.Position).Magnitude)
                            draws.dist.Position = Vector2.new(screenPos.X, screenPos.Y + 44)
                            draws.dist.Text = distance .. "m"
                            draws.dist.Color = espColor
                            draws.dist.Visible = true
                        end
                        if state.tracersEnabled and draws.tracer then
                            local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
                            draws.tracer.From = center
                            draws.tracer.To = screenPos
                            draws.tracer.Color = tracerColor
                            draws.tracer.Visible = true
                        elseif draws.tracer then
                            draws.tracer.Visible = false
                        end

                        -- health bars
                        if state.healthBarsEnabled and draws.health and draws.healthBack then
                            local hum = char:FindFirstChildOfClass("Humanoid")
                            local healthPerc = 0
                            if hum and hum.MaxHealth > 0 then healthPerc = clamp(hum.Health / hum.MaxHealth, 0, 1) end
                            local barW = 6
                            local barH = 60 * (clamp(1/(screenPos3.Z*0.002 + 0.001),0.6,2))
                            local x = screenPos.X - (boxW/2) - 12
                            local y = screenPos.Y - barH/2 - 20
                            draws.healthBack.Position = Vector2.new(x, y)
                            draws.healthBack.Size = Vector2.new(barW, barH)
                            draws.healthBack.Color = Color3.fromRGB(40,40,40)
                            draws.healthBack.Visible = true

                            draws.health.Position = Vector2.new(x, y + (1-healthPerc) * barH)
                            draws.health.Size = Vector2.new(barW, barH * healthPerc)
                            local healthColor = Color3.fromRGB(255 * (1 - healthPerc), 255 * healthPerc, 0)
                            draws.health.Color = healthColor
                            draws.health.Visible = true
                        end
                    end
                else
                    if draws then
                        pcall(function()
                            if draws.box then draws.box.Visible = false end
                            if draws.name then draws.name.Visible = false end
                            if draws.dist then draws.dist.Visible = false end
                            if draws.tracer then draws.tracer.Visible = false end
                            if draws.health then draws.health.Visible = false; draws.healthBack.Visible = false end
                        end)
                    end
                end
            end
        end
    end
end

-- ======= Main RenderStepped loop =======
local aimTick = 0
local aimHold = false
local aimHeld = false -- mobile hold flag

RunService.RenderStepped:Connect(function(dt)
    -- update hue for rainbow effects
    if state.rainbowESP or state.rainbowGlow or state.fovRainbow then
        state.hue = (state.hue + dt * 0.12) % 1
    end

    updateESP(dt)

    -- PC mouse hold check for aimbot
    local mouseHold = UserInputService:IsMouseButtonPressed(CONFIG.aimMouseButton)
    local shouldAim = state.aimbotEnabled and (mouseHold or aimHold)
    if shouldAim then
        aimTick = aimTick + dt
        if aimTick >= (CONFIG.mobileVirtualAimHoldTimeout or 0.03) then
            aimTick = 0
            local target = chooseTarget()
            if target then smoothLookAt(target) end
        end
    else
        aimTick = 0
    end
end)

-- ======= Input / Hotkeys =======
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        local kc = input.KeyCode
        if kc == CONFIG.hotkeys.toggleUI then
            -- Toggle visibility is managed by external UI (AppleLibrary). We still toggle state flag.
            state.uiVisible = not state.uiVisible
            saveSettings()
        elseif kc == CONFIG.hotkeys.toggleESP then
            state.espEnabled = not state.espEnabled; saveSettings()
        elseif kc == CONFIG.hotkeys.toggleAimbot then
            state.aimbotEnabled = not state.aimbotEnabled; saveSettings()
        elseif kc == CONFIG.hotkeys.toggleGlow then
            state.glowEnabled = not state.glowEnabled; saveSettings()
        end
    end
end)

-- ======= Notification helper (local) =======
local function notify_local(text, duration)
    duration = duration or 3
    -- If TweenService and CoreGui available, make a small notif. Keep it simple & safe.
    local ok, success = pcall(function()
        local notif = Instance.new("Frame")
        notif.Size = UDim2.new(0,320,0,60)
        notif.Position = UDim2.new(1,-340,0,20)
        notif.BackgroundColor3 = Color3.fromRGB(18,18,18)
        notif.BorderSizePixel = 0
        local corner = Instance.new("UICorner", notif); corner.CornerRadius = UDim.new(0,8)
        local bar = Instance.new("Frame", notif)
        bar.Size = UDim2.new(0.02,0,1,0)
        bar.BackgroundColor3 = Color3.fromRGB(255,200,0)
        bar.BorderSizePixel = 0
        local label = Instance.new("TextLabel", notif)
        label.Size = UDim2.new(1,-16,1,0)
        label.Position = UDim2.new(0.02,8,0,0)
        label.BackgroundTransparency = 1
        label.Text = text
        label.Font = Enum.Font.GothamSemibold
        label.TextColor3 = Color3.fromRGB(230,230,230)
        label.TextXAlignment = Enum.TextXAlignment.Left
        notif.Parent = game.CoreGui
        TweenService:Create(notif, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(1,-340,0,20)}):Play()
        task.delay(duration, function()
            TweenService:Create(notif, TweenInfo.new(0.35), {Position = UDim2.new(1,50,0,20)}):Play()
            task.delay(0.35, function() pcall(function() notif:Destroy() end) end)
        end)
    end)
    -- fallback to print
    if not ok then
        print(text)
    end
end

-- Try to load AppleLibrary UI and bind controls
local library_ok, library = pcall(function()
    return loadstring(game:HttpGet("https://github.com/GoHamza/AppleLibrary/blob/main/main.lua?raw=true"))()
end)

if library_ok and library then
    local window = library:init(CONFIG.name, true, CONFIG.uiToggleKey, true)

    window:Divider("XP Scripts • Enhanced ESP + Aimbot")

    local sectionA = window:Section("Visual")
    sectionA:Switch("ESP", state.espEnabled, function(val)
        state.espEnabled = val; saveSettings()
    end)
    sectionA:Switch("Glow (Highlight)", state.glowEnabled, function(val)
        state.glowEnabled = val; saveSettings()
    end)
    sectionA:Switch("Tracers (Lines)", state.tracersEnabled, function(val)
        state.tracersEnabled = val; saveSettings()
    end)
    sectionA:Switch("Health Bars", state.healthBarsEnabled, function(val)
        state.healthBarsEnabled = val; saveSettings()
    end)
    sectionA:Switch("Team Check", state.teamCheck, function(val)
        state.teamCheck = val; saveSettings()
    end)
    sectionA:Switch("Wall Check (Raycast)", state.wallCheck, function(val)
        state.wallCheck = val; saveSettings()
    end)

    window:Divider("Aimbot")
    local sectionB = window:Section("Aimbot")
    sectionB:Switch("Aimbot", state.aimbotEnabled, function(val) state.aimbotEnabled = val; saveSettings() end)
    sectionB:Switch("Show FOV", state.showFov, function(val) state.showFov = val; if fovCircle then fovCircle.Visible = state.showFov end saveSettings() end)
    sectionB:Switch("FOV Rainbow", state.fovRainbow, function(val) state.fovRainbow = val; saveSettings() end)
    sectionB:Switch("Rainbow ESP", state.rainbowESP, function(val) state.rainbowESP = val; saveSettings() end)
    sectionB:Switch("Rainbow Glow", state.rainbowGlow, function(val) state.rainbowGlow = val; saveSettings() end)

    sectionB:TextField("FOV Radius (50-700)", tostring(state.fovRadius), function(txt)
        local n = tonumber(txt)
        if n then state.fovRadius = clamp(n, 50, 700); if fovCircle then fovCircle.Radius = state.fovRadius end saveSettings() end
    end)
    sectionB:TextField("Aimbot Smoothness 0-1 (0 = instant)", tostring(state.smoothingFactor), function(txt)
        local n = tonumber(txt)
        if n then state.smoothingFactor = clamp(n, 0, 1); saveSettings() end
    end)

    window:Divider("Target / Priority")
    local sectionC = window:Section("Target")
    sectionC:Button("Cycle Priority", function()
        local listPriority = {"Closest","LowestHealth","ClosestVisible"}
        for i,v in ipairs(listPriority) do
            if v == state.targetPriority then
                state.targetPriority = listPriority[i % #listPriority + 1]
                break
            end
        end
        sectionC:Label("Target Priority: " .. state.targetPriority)
        saveSettings()
    end)
    sectionC:TextField("Target Part (Head/UpperTorso/Root)", state.targetPart, function(txt)
        if txt and #txt > 0 then state.targetPart = txt; saveSettings() end
    end)

    window:Divider("Colors & Presets")
    local sectionD = window:Section("Colors")
    sectionD:Button("ESP White Preset", function()
        state.colorPresets.esp = {r=255,g=255,b=255}; saveSettings()
    end)
    sectionD:Button("ESP Cyan Preset", function()
        state.colorPresets.esp = {r=0,g=200,b=255}; saveSettings()
    end)
    sectionD:Button("Glow Red Preset", function()
        state.colorPresets.glow = {r=255,g=0,b=0}; saveSettings()
    end)
    sectionD:Button("FOV Orange Preset", function()
        state.colorPresets.fov = {r=255,g=200,b=0}; if fovCircle then fovCircle.Color = rgb(state.colorPresets.fov) end saveSettings()
    end)

    window:Divider("Misc")
    local sectionE = window:Section("Misc")
    sectionE:Button("Save Settings Now", function() saveSettings(); window:TempNotify("Saved", "Settings saved to file (if supported).", "rbxassetid://12608259004") end)
    sectionE:Button("Reset Settings", function()
        -- lightweight reset
        state.espEnabled = false
        state.glowEnabled = false
        state.aimbotEnabled = false
        state.teamCheck = false
        state.wallCheck = false
        state.fovRadius = 150
        state.smoothingFactor = 0.5
        state.rainbowESP = false
        state.rainbowGlow = false
        state.fovRainbow = false
        saveSettings()
        window:TempNotify("Reset", "Settings reset to defaults.", "rbxassetid://12608259004")
    end)

    window:GreenButton(function() notify_local(CONFIG.name .. " - controls available in the UI") end)

    -- initial label to show priority
    sectionC:Label("Target Priority: " .. state.targetPriority)
else
    -- Library cannot be loaded: fallback to small notifications & console
    notify_local("Failed to load UI library. Running headless. Use console or enable features in code.", 6)
end

-- Small console notification
print(CONFIG.name .. " - ultimate mobile-friendly script loaded. Use the injected UI (AppleLibrary) to control features if available.")

-- Save settings periodically and on exit if possible
spawn(function()
    while true do
        task.wait(10)
        saveSettings()
    end
end)
